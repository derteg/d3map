<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Accidents on the Road - Choropleth</title>
  <script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>
  <script type="text/javascript" src="http://d3js.org/queue.v1.min.js"></script>
  <script type="text/javascript" src="http://d3js.org/topojson.v0.min.js"></script>
  <!--script type="text/javascript" src="http://d3js.org/topojson.v1.min.js"></script -->
</head>
<style>
	path {
	  stroke:white;
	  stroke-width: 1px;
	}
	body {
		background-color: #e1f5fd;
		margin: 0;
	}
	.map-energy {
		text-align: center;
	}
</style>
<body>
<div class="map-energy"></div>
  <script type="text/javascript">
	var width = 1040,
		height = 540,
		region,
		station,
		stationData,
		centered,
		/*
			Для растягивания проекции нужно указать параметр 'scale', который по умолчанию равен '150'.
			Для нашей проекции нужно посчитать 'scale' вручную. Смотрим width и height у проекции (с масштабом по умолчанию 150)
			Выбираем меньшее из двух.
		*/
		scale0 = Math.min(150 / 186 * width, 150 / 102 * height),
		active = d3.select(null);

	// Создаём функцию проекции
	var projection = d3.geo.albers()
		.rotate([-105, 0])
		.center([-10, 65])
		.parallels([52, 64])
		.scale(scale0)
		.translate([width / 2, height / 2]);

	// Создаем функцию, которая будет преобразовывать географические координаты в формат пути для элемента <path>
	var path = d3.geo.path().projection(projection).pointRadius(1);	

	// Создаём объект, ответственный за масштабирование
	var zoom = d3.behavior.zoom()
		.scaleExtent([1, 60])
		.size([width, height])
		.on("zoom", onZoomed);

	// Создаём элемент <svg>, где и будет рисоваться карта
	var svg = d3.select(".map-energy").append("svg")
		.attr("width", width)
		.attr("height", height)
		.attr("class", "map-energy__svg")
		.call(zoom);

	// Создаем элемент группы <g>, в который будут вкладываться все другие элементы
	var regionsBox = svg.append("g")
			.attr("class", "map-energy__regions");

	// Рендерим карту из данных
	queue()
		.defer(d3.json, "ajax/russia_topo.json")
		.defer(d3.csv, "ajax/Accidents.csv")
		.defer(d3.tsv, "ajax/cities.tsv")
		.await(ready);

	//Start of Choropleth drawing
	function ready(error, map, data1, data2) {
		var rateById = {};
		var nameById = {};

		if(error) {
			console.log(error);
			return;
		}

		data1.forEach(function(d) {
			rateById[d.RegionCode] = d.Color;
			nameById[d.RegionCode] = d.RegionName;
		});

		//Drawing Choropleth
		var countries = topojson.object(map, map.objects.name).geometries;
		region = regionsBox.selectAll("path").data(countries).enter()
			.append("path")
			.attr("d", path)
			.style("stroke-width", "0")
			.style("fill", function(d) {
				return rateById[d.properties.region];
			})
			.style("opacity", 1)
			.on("mouseover", function(d) {
				d3.select(this).transition().duration(300).style("fill", "#0865b4");
			})
			.on("mouseout", function() {
				d3.select(this)
					.transition().duration(300)
					.style("fill", function(d) {return rateById[d.properties.region];});
			});

		station = regionsBox.selectAll("g.map-energy__station")
			.data(data2)
			.enter()
			.append("path")
			.attr("class", "map-energy__station")
			.attr('d', function (d) {
				return path({
					'type': 'Point',
					'coordinates': [d.lon, d.lat]
				});
			});
			// .attr("transform", function(d) {
			// 	return "translate(" + projection([d.lon, d.lat]) + ")";
			// });

		station.append("a")
			.attr("xlink:href", function(d) {return d.Link;});
		
		station.selectAll("a")
			.append("circle")
			.attr("r", 13)
			.attr("fill", "#cce4f9")
			.attr("stroke", "white")
			.attr("stroke-width", "2px");

		station.selectAll("a")
			.append('svg:image')
			.attr('x',-11)
			.attr('y',-11)
			.attr('width', 22)
			.attr('height', 22)
			.attr("xlink:href", function(d) {return d.Type;})
			.style("cursor", "pointer");
	}	// <-- End of Choropleth drawing

	// Обработчик события zoom, который вызывается каждый раз, когда пользовать хочет
	// измениеть положение или масштаб карты
	function onZoomed() {
		// Получаем желамые положение и масштаб карты из события
		var t = d3.event.translate;
		var s = d3.event.scale;

		// Проверям, чтобы новое положение не выходило за границы
		t[0] = Math.max(Math.min(t[0], 0), width * (1 - s));
		t[1] = Math.max(Math.min(t[1], 0), height * (1 - s));

		// Записываем новое положение обратно в zoom
		zoom.translate(t);

		// Меняем масштаб и положение карты на экране
		regionsBox
		.attr('transform', 'translate(' + t + ')scale(' + s + ')');
		
		// Устанавливаем новый радиус для всех точек
        path.pointRadius(Math.max(1/4, 1/s));
	}
  </script>
</body>
</html>